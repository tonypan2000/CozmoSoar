#DEPRICATED left for notes


#contains common boardgame concepts

#predicates

#match-attribute

#COMPLETE 3
#TESTED 3
#eight puzzle predicates
#match-color
#different-colr
#matched-on-color
#mismatch-on-color
#all-matched count matched = count on-matched


#all-covered
#all-empty
#diceroll

#functions
#state-eval

#for now block-location match to limit duplicates


sp {topstate*elaborate*match-color
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name match-color)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs> <cs2> ^aname match-color)

   
   (<cs> ^result.set <res> ^name word ^parameter <param1> ^return-type number ^rtype single ^negative false ^args <ag> ^type attribute-of)#^type function ^function attribute-of)
   (<ag> ^2 <c3> ^num 1)
   (<param1> ^1 <p11> ^2 <p12> ^num 2)
   (<p11> ^param-id 3 ^type single)
   (<p12> ^param-id 1 ^type single)
   
   (<cs2> ^result.set <res3> ^name word ^parameter <param2> ^return-type number ^rtype single ^negative false ^args <ag2> ^type attribute-of)#^type function ^function attribute-of)
   (<ag2> ^2 <c2> ^num 1)
   (<param2> ^1 <p21> ^2 <p22> ^num 2)
   (<p21> ^param-id 3 ^type single)
   (<p22> ^param-id 2 ^type single)
   

   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<c3> ^name block ^parameter.num 0 ^negative false ^args <arg13> ^rtype single ^type attribute ^attribute type ^result.set <rset53>)
   (<arg13> ^1 <c5> ^num 1)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}
#HERE ASDF
sp {topstate*elaborate*different-colorasdf
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name asdfdifferent-color)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 4)


  (<nlps> ^nlp <c4> <cs> <cs2> ^aname different-color)

   (<c4> ^result.set <res4> ^name different ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^type function ^function comparison)
   (<pz2> ^1 <p1z> ^2 <p2z> ^num 2)
   (<p1z> ^param-id 3 ^type single)
   (<p2z> ^param-id 4 ^type single)
   (<agf2> ^1 <cs> ^2 <cs2> ^num 2)
   
   (<cs> ^result.set <res> ^name word ^parameter <param1> ^return-type number ^rtype single ^negative false ^args <ag> ^type attribute-of)#^type function ^function attribute-of)
   (<ag> ^2 <c5> ^num 1)
   (<param1> ^1 <p11> ^2 <p12> ^num 2)
   (<p11> ^param-id 3 ^type single)
   (<p12> ^param-id 1 ^type single)
   
   (<cs2> ^result.set <res3> ^name word ^parameter <param2> ^return-type number ^rtype single ^negative false ^args <ag2> ^type attribute-of)#^type function ^function attribute-of)
   (<ag2> ^2 <c5> ^num 1)
   (<param2> ^1 <p21> ^2 <p22> ^num 2)
   (<p21> ^param-id 4 ^type single)
   (<p22> ^param-id 2 ^type single)
   
   #(<c1> ^name block ^rtype single ^type attribute ^attribute type)
            
	(<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
}

#2
sp {topstate*elaborate*match-on-color
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name match-on-color)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)


  (<nlps> ^nlp <cs1> <c4> ^aname match-on-color)

   (<c4> ^result.set <res3> ^name match-color ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   (<pz2> ^1 <p1z> ^2 <p2z> ^num 2)
   (<p1z> ^param-id 1 ^type single)
   (<p2z> ^param-id 2 ^type single)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name on ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^num 2)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<ag1> ^1 <c5> ^2 <c5> ^num 2)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}

#2
sp {topstate*elaborate*mismatch-on-color
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name mismatch-on-color)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)


  (<nlps> ^nlp <cs1> <c4> ^aname mismatch-on-color)

   (<c4> ^result.set <res3> ^name match-color ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   (<pz2> ^1 <p1z> ^2 <p2z> ^num 2)
   (<p1z> ^param-id 1 ^type single)
   (<p2z> ^param-id 2 ^type single)
   
   (<cs1> ^result.set <res> ^rtype single ^negative true ^name on ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^num 2)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<ag1> ^1 <c4> ^2 <c5> ^num 2)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}
#3
sp {topstate*elaborate*all-8-matched
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name all-8-matched)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs1> <c4> ^aname all-8-matched)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^num 1)
   (<p1b> ^param-id 1 ^type single)
  # (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 1 ^type single)
   (<resp> ^1 8)

   
   (<cs2> ^name match-on-color ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)
   
}
###########################################################



###########################################################
#todo test
#dice-roll
#flank 2 locations and a set of locations (function?


#tested with backgammon!
#2
sp {topstate*elaborate*dice-roll
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name dice-roll)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 4)

(<nlps> ^nlp <c99> 
           ^nlp <c6> ^aname dice-roll)   
   
   (<c99> ^name value ^return-type number ^negative false ^rtype single ^args <ag33> ^parameter <pp1> ^type attribute-of ^result.set <rset522>)
   (<pp1> ^1 <p11z> ^num 1)
   (<p11z> ^param-id 4 ^type single)

   (<ag33> ^2 <c3> ^num 1)
   
   (<c3> ^name dice ^args <ag9> ^parameter.num 0 ^rtype single ^negative false ^type attribute ^attribute word ^result.set <rset52>)
   (<ag9> ^1 <c5> ^num 1)
   
   (<c6> ^name count ^rtype single ^return-type number ^negative false ^args <ag34> ^parameter <ppp> ^type function ^function soar-count ^result.set <rset59>)
   (<ppp> ^1 <pa21> ^2 <pa21b> ^num 2) #TODO fix for allowing ^2 be main
   (<pa21b> ^param-id 3 ^type set)
   (<pa21> ^param-id 4 ^type single)
   (<ag34> ^2 <c6a> ^num 1) 
   
   (<c6a> ^name between-inclusive ^rtype set ^negative false ^args <ag11> ^parameter <p3z7> ^type function ^function board-between ^result.set <rset56>)
   (<p3z7> ^2 <pa11> ^3 <pa11a> ^1 <pa11b> ^num 3)
   (<pa11b> ^param-id 3 ^type set)
   (<pa11> ^param-id 1 ^type single)
   (<pa11a> ^param-id 2 ^type single)
   (<ag11> ^2 <c4> ^3 <c2> ^1 <c2> ^num 3)

   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<c4> ^result.set <res3> ^name own ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
 (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
}

#tested with backgammon!
#2
sp {topstate*elaborate*multi-dice-roll
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name multi-dice-roll)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)

(<nlps> ^nlp <css> 
        ^nlp <c6> ^aname multi-dice-roll)   
   
   
   (<css> ^name sum ^rtype single ^result.set <res> ^args <ags> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-sum)
   (<p3z> ^1 <p1> ^2 <p2> ^num 2)
   (<p1> ^param-id 4 ^type single)
   (<p2> ^param-id 5 ^type set)
   (<ags> ^2 <c99> ^num 1)    
                                     
   (<c99> ^name value ^rtype set ^args <ag33> ^parameter <pp1> ^negative false ^type attribute-of ^result.set <rset522>)
   (<pp1> ^1 <p11z> ^num 1)
   (<p11z> ^param-id 5 ^type set)

   (<ag33> ^2 <c3> ^num 1)
   
   (<c3> ^name dice ^args <ag9> ^parameter.num 0 ^rtype set ^negative false ^type attribute ^attribute word ^result.set <rset52>)
   (<ag9> ^1 <c5> ^num 1)
   
   (<c6> ^name count ^negative false ^rtype single ^return-type number ^args <ag34> ^parameter <ppp> ^type function ^function soar-count ^result.set <rset59>)
   (<ppp> ^1 <pa21> ^2 <pa21b> ^num 2) #TODO fix for allowing ^2 be main
   (<pa21b> ^param-id 3 ^type set)
   (<pa21> ^param-id 4 ^type single)
   (<ag34> ^2 <c6a> ^num 1) 
   
   (<c6a> ^name between-inclusive ^negative false ^rtype set ^args <ag11> ^parameter <p3z7> ^type function ^function board-between ^result.set <rset56>)
   (<p3z7> ^2 <pa11> ^3 <pa11a> ^1 <pa11b> ^num 3)
   (<pa11b> ^param-id 3 ^type set)
   (<pa11> ^param-id 1 ^type single)
   (<pa11a> ^param-id 2 ^type single)
   (<ag11> ^2 <c4> ^3 <c2> ^1 <c2> ^num 3)

   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<c4> ^result.set <res3> ^name own ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
 (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
}


#tested with risk!
sp {topstate*elaborate*all-covered
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name all-covered)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs2> ^aname all-covered)
   
   
   (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <c2> ^2 <c5> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)

    (<c2> ^name location ^parameter <p2> ^negative false ^args <arg11> ^rtype set ^type attribute ^attribute type ^result.set <rset5>)
    (<arg11> ^1 <c5> ^num 1)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 1 ^type set)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
   
}

#tested with risk!
#2
sp {topstate*elaborate*all-captured
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name all-captured)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs2> ^aname all-captured)
   
   
   (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <c2> ^2 <c6> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)
   
   (<c6> ^result.set <res3> ^name mine ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)

    (<c2> ^name location ^parameter <p2> ^negative false ^args <arg11> ^rtype set ^type attribute ^attribute type ^result.set <rset5>)
    (<arg11> ^1 <c5> ^num 1)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 1 ^type set)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
   
}
#tested with risk!
#2
sp {topstate*elaborate*all-occupied
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name all-occupied)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs2> ^aname all-occupied)
   
   
   (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <c2> ^2 <c6> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)
   
   (<c6> ^result.set <res3> ^name opponent ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)

    (<c2> ^name location ^parameter <p2> ^negative false ^args <arg11> ^rtype set ^type attribute ^attribute type ^result.set <rset5>)
    (<arg11> ^1 <c5> ^num 1)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 1 ^type set)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
   
}
#tested on risk
sp {topstate*elaborate*all-clear
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name all-clear)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs2> ^aname all-clear)
   
   
   (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative true ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <c2> ^2 <c5> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)

    (<c2> ^name location ^parameter <p2> ^negative false ^args <arg11> ^rtype set ^type attribute ^attribute type ^result.set <rset5>)
    (<arg11> ^1 <c5> ^num 1)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 1 ^type set)
   
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
         ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
    (<P225> ^num 0)
    (<R94> ^set <S158>)
   
}

#tested on risk
#2
sp {topstate*elaborate*more-owned
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name more-owned)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <c8> ^aname more-owned)  
   
   (<c6> ^name occupied ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)

   (<c5> ^name own ^rtype single ^negative false ^args <ag56> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset66>)

   (<cs> ^name count ^rtype single ^result.set <res> ^args <ag> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-count)
   (<p3z> ^1 <p1> ^num 1)
   (<p1> ^param-id 1 ^type single)
   #(<p2> ^param-id 1 ^type set)
   (<ag> ^2 <c5> ^num 1)
   
   (<cs2> ^name count ^rtype single ^result.set <res4> ^args <ag2> ^negative false ^parameter <p2z> ^return-type number ^type function ^function soar-count)
   (<p2z> ^1 <p12> ^num 1)
   (<p12> ^param-id 2 ^type single)
   #(<p22> ^param-id 2 ^type set)
   (<ag2> ^2 <c6> ^num 1)
      
   (<c8> ^name greater ^rtype single ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-greater)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 2 ^type single)
   (<ag8> ^1 <cs> ^2 <cs2> ^num 2)
   
}

#tested on risk
#2
sp {topstate*elaborate*more-occupied
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name more-occupied)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <c8> ^aname more-occupied)  
   
   (<c5> ^name occupied ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)

   (<c6> ^name own ^rtype single ^negative false ^args <ag56> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset66>)

   (<cs> ^name count ^rtype single ^result.set <res> ^args <ag> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-count)
   (<p3z> ^1 <p1> ^num 1)
   (<p1> ^param-id 1 ^type single)
   #(<p2> ^param-id 1 ^type set)
   (<ag> ^2 <c5> ^num 1)
   
   (<cs2> ^name count ^rtype single ^result.set <res4> ^args <ag2> ^negative false ^parameter <p2z> ^return-type number ^type function ^function soar-count)
   (<p2z> ^1 <p12> ^num 1)
   (<p12> ^param-id 2 ^type single)
   #(<p22> ^param-id 2 ^type set)
   (<ag2> ^2 <c6> ^num 1)
      
   (<c8> ^name greater ^rtype single ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-greater)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 2 ^type single)
   (<ag8> ^1 <cs> ^2 <cs2> ^num 2)
   
}

#tested on risk
sp {topstate*elaborate*occupied-locations
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name occupied-locations)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs2> ^aname occupied-locations)

 (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <cs3> ^2 <cs> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)
   
   (<cs3> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
   (<ag3> ^1 <c5> ^num 1)
   
   (<cs> ^result.set <res3> ^name blue ^parameter.num 0 ^rtype single ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}
#tested on risk
sp {topstate*elaborate*owned-locations
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name owned-locations)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs2> ^aname owned-locations)

 (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype set ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <cs3> ^2 <cs> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type set)
   
   (<cs3> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
   (<ag3> ^1 <c5> ^num 1)
   
   (<cs> ^result.set <res3> ^name red ^parameter.num 0 ^rtype single ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}
#tested on risk
#2
sp {topstate*elaborate*more-occupied2
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name more-occupied2)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <c8> ^aname more-occupied2)  
   
   (<c5> ^name occupied-locations ^rtype set ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)

   (<c6> ^name owned-locations ^rtype set ^negative false ^args <ag56> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset66>)

   (<cs> ^name count ^rtype single ^result.set <res> ^args <ag> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-count)
   (<p3z> ^1 <p1> ^num 1)
   (<p1> ^param-id 1 ^type single)
   #(<p2> ^param-id 1 ^type set)
   (<ag> ^2 <c5> ^num 1)
   
   (<cs2> ^name count ^rtype single ^result.set <res4> ^args <ag2> ^negative false ^parameter <p2z> ^return-type number ^type function ^function soar-count)
   (<p2z> ^1 <p12> ^num 1)
   (<p12> ^param-id 2 ^type single)
   #(<p22> ^param-id 2 ^type set)
   (<ag2> ^2 <c6> ^num 1)
      
   (<c8> ^name greater ^rtype single ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-greater)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 2 ^type single)
   (<ag8> ^1 <cs> ^2 <cs2> ^num 2)
   
}



#tested on risk
#3
sp {topstate*elaborate*covered-win
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name covered-win)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <cs2> <cs3> ^aname covered-win)
   
   (<cs3> ^name all-covered ^rtype set ^negative false ^args <as> ^parameter <p3> ^type concept ^attribute predicate ^result.set <rset3>)
   (<p3> ^1 <p31> ^num 1)
   (<p31> ^param-id 2 ^type set)
   
   (<cs2> ^name more-owned ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter <p2> ^type concept ^attribute predicate ^result.set <rset>)
   (<p2> ^1 <p21> ^num 1)
   (<p21> ^param-id 1 ^type single)
   
}

#tested on risk
#3
sp {topstate*elaborate*covered-loss
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name covered-loss)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <cs2> <cs3> ^aname covered-loss)
   
   (<cs3> ^name all-covered ^rtype set ^negative false ^args <as> ^parameter <p3> ^type concept ^attribute predicate ^result.set <rset3>)
   (<p3> ^1 <p31> ^num 1)
   (<p31> ^param-id 2 ^type set)
   
   (<cs2> ^name more-occupied ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter <p2> ^type concept ^attribute predicate ^result.set <rset>)
   (<p2> ^1 <p21> ^num 1)
   (<p21> ^param-id 1 ^type single)
   
}
#tested on chess-eval
#2
sp {topstate*elaborate*my-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name my-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs> ^aname my-score)
 
   (<c1> ^name my-pieces ^rtype set ^result.set <res1> ^negative false ^type concept ^attribute predicate ^args <ag2> ^parameter <p37a>) 
   (<p37a> ^1 <p12> ^num 1)
   (<p12> ^param-id 2 ^type set)
   
   (<cs> ^name sum ^rtype single ^result.set <res> ^args <ag> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-sum)
   (<p3z> ^1 <p1> ^2 <p2> ^num 2)
   (<p1> ^param-id 1 ^type single)
   (<p2> ^param-id 3 ^type set)
   (<ag> ^2 <c8> ^num 1)
      
   (<c8> ^name value ^rtype set ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^type attribute-of)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 3 ^type set)
   (<p182> ^param-id 2 ^type set)
   (<ag8> ^2 <c1> ^num 1)

   (<T5> ^nlp-set <nlps>)
}

#tested on chess-eval
sp {topstate*elaborate*opponent-pieces
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name opponent-pieces)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs> ^aname opponent-pieces)#^nlp <cs> <cs1>

   
   (<cs> ^result.set <res> ^name blue ^parameter <param1> ^rtype set ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
   (<param1> ^1 <p11> ^num 1)
   (<p11> ^param-id 1 ^type set)
   #(<c1> ^name block ^rtype single ^type attribute ^attribute type)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}

#tested on chess-eval
#2
sp {topstate*elaborate*enemy-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name enemy-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs> ^aname enemy-score)
 
   (<c1> ^name opponent-pieces ^rtype set ^result.set <res1> ^negative false ^type concept ^attribute predicate ^args <ag2> ^parameter <p37a>) 
   (<p37a> ^1 <p12> ^num 1)
   (<p12> ^param-id 2 ^type set)
   
   (<cs> ^name sum ^rtype single ^result.set <res> ^args <ag> ^negative false ^parameter <p3z> ^return-type number ^type function ^function soar-sum)
   (<p3z> ^1 <p1> ^2 <p2> ^num 2)
   (<p1> ^param-id 1 ^type single)
   (<p2> ^param-id 3 ^type set)
   (<ag> ^2 <c8> ^num 1)
      
   (<c8> ^name value ^rtype set ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^type attribute-of)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 3 ^type set)
   (<p182> ^param-id 2 ^type set)
   (<ag8> ^2 <c1> ^num 1)

   (<T5> ^nlp-set <nlps>)
}

#tested on chess-eval
#3
sp {topstate*elaborate*net-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name net-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)

  (<nlps> ^nlp <cs1> ^aname net-score)
   
   
   (<cs1> ^name subtract ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-math)
   (<ag1> ^2 <cs2> ^3 <cs3> ^num 2)
   (<p3z> ^1 <pa11b> ^num 1)
   (<pa11b> ^param-id 1 ^type single)
   
   (<cs2> ^name my-score ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)
   (<cs3> ^name enemy-score ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset1>)
   
}

#tested on chess-eval
#3
sp {topstate*elaborate*winning-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name winning-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <c8> ^aname winning-score)
   
   (<c8> ^name greater ^rtype single ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-greater)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 2 ^type single)
   (<ag8> ^1 <cs2> ^2 <cs3> ^num 2)
   
   (<cs2> ^name my-score ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)
   (<cs3> ^name enemy-score ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset1>)
   
}
#tested on chess-eval
#3
sp {topstate*elaborate*losing-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name losing-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <c8> ^aname losing-score)
   
   (<c8> ^name more ^rtype single ^result.set <res2> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-greater)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 2 ^type single)
   (<ag8> ^1 <cs2> ^2 <cs3> ^num 2)
   
   (<cs2> ^name my-score ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset>)
   (<cs3> ^name enemy-score ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter.num 0 ^type concept ^attribute predicate ^result.set <rset1>)
   
}
#tested on chess-eval
#3
sp {topstate*elaborate*tie-score
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name tie-score)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 2)

  (<nlps> ^nlp <cs2> <cs3> ^aname tie-score)
   
   (<cs2> ^name my-score ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter <p22> ^type concept ^attribute predicate ^result.set <rset>)
   (<cs3> ^name enemy-score ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter <p33> ^type concept ^attribute predicate ^result.set <rset1>)
   (<p22> ^1 <p18> ^num 1)
   (<p18> ^param-id 1 ^type single)
   (<p33> ^1 <p333> ^num 1)
   (<p333> ^param-id 2 ^type single)
   
}




#no input version (need version with input)
#tested on tictactoe-small
sp {topstate*elaborate*absolute-dx
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name absolute-dx)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 6)


  (<nlps> ^nlp <c8> ^aname absolute-dx)

  (<c8> ^name absolute-value ^rtype single ^result.set <res20> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-math)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 6 ^type single)
   (<ag8> ^2 <c4> ^num 1)
   
  
   (<c4> ^result.set <res4> ^name subtract ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^return-type number ^type function ^function soar-math)
   (<pz2> ^1 <p1z> ^2 <p2z> ^3 <p3z> ^num 3)
   (<p1z> ^param-id 6 ^type single)
   (<p2z> ^param-id 4 ^type single)
   (<p3z> ^param-id 5 ^type single)
   (<agf2> ^2 <csx> ^3 <csx2> ^num 2)
   
   
   (<csx> ^result.set <res> ^name x ^parameter <param1> ^return-type number ^rtype single ^negative false ^args <ag> ^type attribute-of)#^type function ^function attribute-of)
   (<ag> ^2 <c5> ^num 1)
   (<param1> ^1 <p11> ^2 <p12> ^num 2)
   (<p11> ^param-id 4 ^type single)
   (<p12> ^param-id 2 ^type single)
   
   (<csx2> ^result.set <res30> ^name x ^parameter <param2> ^return-type number ^rtype single ^negative false ^args <ag2> ^type attribute-of)#^type function ^function attribute-of)
   (<ag2> ^2 <c5> ^num 1)
   (<param2> ^1 <p21> ^2 <p22> ^num 2)
   (<p21> ^param-id 5 ^type single)
   (<p22> ^param-id 3 ^type single)
   
   
    (<c5> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
    (<ag3> ^1 <c6> ^num 1)        
	(<c6> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
}
#tested on tictactoe-small
sp {topstate*elaborate*dy
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name dy)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)


  (<nlps> ^nlp <c4> ^aname dy)
   
  
   (<c4> ^result.set <res4> ^name subtract ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^return-type number ^type function ^function soar-math)
   (<pz2> ^1 <p1z> ^2 <p2z> ^3 <p3z> ^num 3)
   (<p1z> ^param-id 1 ^type single)
   (<p2z> ^param-id 4 ^type single)
   (<p3z> ^param-id 5 ^type single)
   (<agf2> ^2 <csx> ^3 <csx2> ^num 2)
   
   
   (<csx> ^result.set <res> ^name y ^parameter <param1> ^return-type number ^rtype single ^negative false ^args <ag> ^type attribute-of)#^type function ^function attribute-of)
   (<ag> ^2 <c5> ^num 1)
   (<param1> ^1 <p11> ^2 <p12> ^num 2)
   (<p11> ^param-id 4 ^type single)
   (<p12> ^param-id 2 ^type single)
   
   (<csx2> ^result.set <res30> ^name y ^parameter <param2> ^return-type number ^rtype single ^negative false ^args <ag2> ^type attribute-of)#^type function ^function attribute-of)
   (<ag2> ^2 <c5> ^num 1)
   (<param2> ^1 <p21> ^2 <p22> ^num 2)
   (<p21> ^param-id 5 ^type single)
   (<p22> ^param-id 3 ^type single)
   
   
    (<c5> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
    (<ag3> ^1 <c6> ^num 1)        
	(<c6> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
}
#tested on tictactoe-small
sp {topstate*elaborate*dx
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name dx)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)


  (<nlps> ^nlp <c4> ^aname dx)
   
  
   (<c4> ^result.set <res4> ^name subtract ^negative false ^parameter <pz2> ^rtype single ^args <agf2> ^return-type number ^type function ^function soar-math)
   (<pz2> ^1 <p1z> ^2 <p2z> ^3 <p3z> ^num 3)
   (<p1z> ^param-id 1 ^type single)
   (<p2z> ^param-id 4 ^type single)
   (<p3z> ^param-id 5 ^type single)
   (<agf2> ^2 <csx> ^3 <csx2> ^num 2)
   
   
   (<csx> ^result.set <res> ^name x ^parameter <param1> ^return-type number ^rtype single ^negative false ^args <ag> ^type attribute-of)#^type function ^function attribute-of)
   (<ag> ^2 <c5> ^num 1)
   (<param1> ^1 <p11> ^2 <p12> ^num 2)
   (<p11> ^param-id 4 ^type single)
   (<p12> ^param-id 2 ^type single)
   
   (<csx2> ^result.set <res30> ^name x ^parameter <param2> ^return-type number ^rtype single ^negative false ^args <ag2> ^type attribute-of)#^type function ^function attribute-of)
   (<ag2> ^2 <c5> ^num 1)
   (<param2> ^1 <p21> ^2 <p22> ^num 2)
   (<p21> ^param-id 5 ^type single)
   (<p22> ^param-id 3 ^type single)
   
   
    (<c5> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
    (<ag3> ^1 <c6> ^num 1)        
	(<c6> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
}
#tested on tictactoe-small
#2
sp {topstate*elaborate*absolute-dy
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name absolute-dy)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 4)


  (<nlps> ^nlp <c8> ^aname absolute-dy)

  (<c8> ^name absolute-value ^rtype single ^result.set <res20> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-math)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 4 ^type single)
   (<ag8> ^2 <cs3> ^num 1)
   
   (<cs3> ^name dy ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter <p2> ^type concept ^attribute predicate ^result.set <rset1>)
   (<p2> ^1 <p21z> ^2 <p22z> ^3 <p23z> ^num 3)
   (<p21z> ^param-id 4 ^type single)
   (<p22z> ^param-id 2 ^type single)
   (<p23z> ^param-id 3 ^type single)
}

#tested on tictactoe-small
#3
sp {topstate*elaborate*manhattan-distance
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name manhattan-distance)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)

  (<nlps> ^nlp <cs1> ^aname manhattan-distance)
   
   
   (<cs1> ^name add ^result.set <res2> ^rtype single ^negative false ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-math)
   (<ag1> ^2 <cs2> ^3 <cs3> ^num 2)
   (<p3z> ^1 <pa11b> ^2 <pa12b> ^3 <pa13b> ^num 3)
   (<pa11b> ^param-id 1 ^type single)
   (<pa12b> ^param-id 4 ^type single)
   (<pa13b> ^param-id 5 ^type single)
   
   (<cs2> ^name absolute-dx ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter <p1> ^type concept ^attribute predicate ^result.set <rset>)
   (<p1> ^1 <p1z> ^2 <p2z> ^3 <p3z> ^num 3)
   (<p1z> ^param-id 4 ^type single)
   (<p2z> ^param-id 2 ^type single)
   (<p3z> ^param-id 3 ^type single)
   
   (<cs3> ^name absolute-dy ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter <p2> ^type concept ^attribute predicate ^result.set <rset1>)
   (<p2> ^1 <p21z> ^2 <p22z> ^3 <p23z> ^num 3)
   (<p21z> ^param-id 5 ^type single)
   (<p22z> ^param-id 2 ^type single)
   (<p23z> ^param-id 3 ^type single)

 }


#2
sp {topstate*elaborate*euclidean-distance
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name euclidean-distance)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 8)

  (<nlps> ^nlp <c8> ^aname euclidean-distance)
  
  (<c8> ^name square-root ^rtype single ^result.set <res2xx> ^args <ag8> ^parameter <p8> ^negative false ^return-type number ^type function ^function soar-math)# ^return-type number)
   (<p8> ^1 <p18> ^2 <p182> ^num 2)
   (<p18> ^param-id 1 ^type single)
   (<p182> ^param-id 8 ^type single)
   (<ag8> ^2 <cs8> ^num 1)#^3 <c7> ^num 2)
   
   #(<c7> ^name number ^rtype single ^negative false ^parameter.num 0 ^result.set.pair <resp> ^return-type number)
   #(<resp> ^1 0.5)
  
   (<cs8> ^name add ^result.set <res2b> ^rtype single ^negative true ^parameter <p8z> ^args <ag823> ^return-type number ^type function ^function soar-math)
   (<ag823> ^2 <cs1> ^3 <cs1b> ^num 2)
   (<p8z> ^1 <p81b> ^2 <p82b> ^3 <p83b> ^num 3)
   (<p81b> ^param-id 8 ^type single)
   (<p82b> ^param-id 6 ^type single)
   (<p83b> ^param-id 7 ^type single)
   
   
   (<cs1> ^name square ^result.set <res2> ^rtype single ^negative false ^parameter <p3z> ^args <ag1> ^return-type number ^type concept ^attribute predicate)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <pa11b> ^2 <pa12b> ^num 2)
   (<pa11b> ^param-id 6 ^type single)
   (<pa12b> ^param-id 4 ^type single)
   
   (<cs1b> ^name square ^result.set <res2ba> ^rtype single ^negative false ^parameter <p3zb> ^args <ag1b> ^return-type number ^type concept ^attribute predicate)
   (<ag1b> ^2 <cs3> ^num 1)
   (<p3zb> ^1 <pa11bb> ^2 <pa12bb> ^num 2)
   (<pa11bb> ^param-id 7 ^type single)
   (<pa12bb> ^param-id 5 ^type single)
   
   
   (<cs2> ^name dx ^return-type number ^rtype single ^negative false ^args <ag5asdf> ^parameter <p1> ^type concept ^attribute predicate ^result.set <rset>)
   (<p1> ^1 <p1z> ^2 <p2z> ^3 <p3z> ^num 3)
   (<p1z> ^param-id 4 ^type single)
   (<p2z> ^param-id 2 ^type single)
   (<p3z> ^param-id 3 ^type single)
   
   (<cs3> ^name dy ^return-type number ^rtype single ^negative false ^args <ag5ff> ^parameter <p2> ^type concept ^attribute predicate ^result.set <rset1>)
   (<p2> ^1 <p21z> ^2 <p22z> ^3 <p23z> ^num 3)
   (<p21z> ^param-id 5 ^type single)
   (<p22z> ^param-id 2 ^type single)
   (<p23z> ^param-id 3 ^type single)

 }

sp {topstate*elaborate*mine
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name mine)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs> ^aname mine)#^nlp <cs> <cs1>

   
   (<cs> ^result.set <res> ^name red ^parameter <param1> ^rtype single ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
   (<param1> ^1 <p11> ^num 1)
   (<p11> ^param-id 1 ^type single)
   #(<c1> ^name block ^rtype single ^type attribute ^attribute type)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}

sp {topstate*elaborate*my-pieces
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name my-pieces)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs> ^aname my-pieces)#^nlp <cs> <cs1>

   
   (<cs> ^result.set <res> ^name red ^parameter <param1> ^rtype set ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
   (<param1> ^1 <p11> ^num 1)
   (<p11> ^param-id 1 ^type set)
   #(<c1> ^name block ^rtype single ^type attribute ^attribute type)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}

sp {topstate*elaborate*own
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name own)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 1)


  (<nlps> ^nlp <cs2> ^aname own)#^nlp <cs> <cs1>

 (<cs2> ^result.set <res> ^name below ^parameter <param2> ^rtype single ^negative false ^args <ag2> ^type state-pair ^attribute prepositions)
   (<ag2> ^1 <cs3> ^2 <cs> ^num 2)
   (<param2> ^1 <p12> ^num 1)
   (<p12> ^param-id 1 ^type single)
   
   (<cs3> ^result.set <res2> ^name location ^parameter.num 0 ^rtype single ^negative false ^args <ag3> ^type attribute ^attribute type)
   (<ag3> ^1 <c5> ^num 1)
  # (<param3> ^1 <p11> ^num 1)
   #(<p13> ^param-id 1 ^type single)
   
   (<cs> ^result.set <res3> ^name red ^parameter.num 0 ^rtype single ^negative false ^args <ag> ^type attribute ^attribute word)
   (<ag> ^1 <c5> ^num 1)
   #(<param1> ^1 <p11> ^num 1)
   #(<p11> ^param-id 1 ^type single)
   #(<c1> ^name block ^rtype single ^type attribute ^attribute type)
     
   (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
 
}

#COMPLETED 6
#TESTED 6 + heuristics
#contains tic-tac-toe board functions

#spatial predicates
#corner
#side
#center
#_x_ win setup
#fork-setup
#_oo block

#heurisitcs here too?
#prefer place center
#prefer place corner over side

sp {topstate*elaborate*center
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name center)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname center)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 4)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}
sp {topstate*elaborate*side
   (state <s> ^name learn-param
            #  ^condition.name adjacent
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name side)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)

(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname side)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 2)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}

sp {topstate*elaborate*corner
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name corner)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname corner)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 1)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}

sp {topstate*elaborate*win-setup
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name win-setup)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs1> ^aname win-setup)

   (<cs> ^result.set <res2> ^name clear ^negative false ^rtype single ^args <agf> ^type concept ^attribute predicate)

   (<c4> ^result.set <res3> ^name own ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name linear-with ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   (<ag1> ^1 <cs> ^2 <c4> ^3 <cs> ^num 3)
 
}
sp {topstate*elaborate*fork-location
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name fork-location)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)


  (<nlps> ^nlp <cs1> <cs2> ^aname fork-location)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name win-setup ^args <agasdf1> ^parameter <pz> ^type concept ^attribute predicate)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   
   (<cs2> ^result.set <res2> ^rtype single ^negative false ^name win-setup ^args <agasdf2> ^parameter <pz2> ^type concept ^attribute predicate)
   (<pz2> ^1 <p1d> ^2 <p2d> ^3 <p3d> ^num 3)
   (<p1d> ^param-id 1 ^type single)
   (<p2d> ^param-id 4 ^type single)
   (<p3d> ^param-id 5 ^type single)
 
}

sp {topstate*elaborate*block-location
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name block-location)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs1> ^aname block-location)

   (<cs> ^result.set <res2> ^name clear ^negative false ^rtype single ^args <agf> ^type concept ^attribute predicate)

   (<c4> ^result.set <res3> ^name occupied ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name linear-with ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   (<ag1> ^1 <cs> ^2 <c4> ^3 <c4> ^num 3)
 
}
#place action
sp {topstate*elaborate*place
   (state <s> ^name learn-param
            #  ^condition.name adjacent
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name place)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)# ^condition <C85> <C86>)
## eight-puzzle action
(<P124> ^argnum 2)


##tic-tac-toe action 
  (<nlps> ^nlp <cs2> <cs> <cs1> ^aname place)#^nlp <cs> <cs1>
   
   (<cs> ^name on ^rtype single ^negative true ^args <ag> ^parameter <p3z> ^type state-pair ^attribute prepositions ^result.set <rset3>)
   (<p3z> ^1 <p1b> ^num 1)
   (<p1b> ^param-id 1 ^type single)
   (<ag> ^1 <cs1> ^2 <c2> ^num 2)

   (<c4> ^name block ^parameter.num 0 ^negative false ^args <arg10> ^rtype single ^type attribute ^attribute type ^result.set <rset4>)
   (<arg10> ^1 <c5> ^num 1)
   
   (<cs1> ^name below ^rtype single ^negative true ^parameter.num 0 ^args <ag1> ^type state-pair ^attribute prepositions ^result.set <rset2>)# ^parameter <pz>)
   (<ag1> ^1 <c4> ^2 <c4> ^num 2)
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name below ^rtype single ^negative true ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^num 1)
   (<p1d> ^param-id 2 ^type single)
   (<ag5> ^1 <c2> ^2 <c4> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}
